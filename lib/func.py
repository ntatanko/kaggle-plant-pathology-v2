{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "# import warnings\n",
    "# warnings.filterwarnings(\"ignore\")\n",
    "from IPython.core.interactiveshell import InteractiveShell\n",
    "\n",
    "InteractiveShell.ast_node_interactivity = \"all\"\n",
    "import matplotlib.image as mpimg\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# %matplotlib inline\n",
    "import sklearn\n",
    "from sklearn import metrics\n",
    "import tensorflow as tf\n",
    "import tensorflow_addons as tfa\n",
    "from PIL import Image\n",
    "from tensorflow import keras\n",
    "from tensorflow.keras.applications.resnet import ResNet50\n",
    "from tensorflow.keras.layers import (\n",
    "    AveragePooling2D,\n",
    "    AvgPool2D,\n",
    "    Conv2D,\n",
    "    Dense,\n",
    "    Flatten,\n",
    "    GlobalAveragePooling2D,\n",
    "    MaxPooling2D,\n",
    ")\n",
    "from tensorflow.keras.layers.experimental import preprocessing\n",
    "from tensorflow.keras.models import Sequential\n",
    "from tensorflow.keras.optimizers import Adam\n",
    "from tensorflow.keras.preprocessing.image import ImageDataGenerator\n",
    "feature_columns = ['complex', 'frog_eye_leaf_spot', 'healthy', 'powdery_mildew', 'rust', 'scab']\n",
    "\n",
    "\n",
    "def get_prediction(predict_train =False, predict_valid=False, all_img = False):\n",
    "    if all_img:\n",
    "        all_img = ImageDataGenerator(rescale=1.0 / 255).flow_from_dataframe(\n",
    "        dataframe=labels,\n",
    "        directory=IMG_PATH,\n",
    "        x_col=\"image\",\n",
    "        y_col=feature_columns,\n",
    "        target_size=IMAGE_SIZE,\n",
    "        batch_size=BATCH_SIZE,\n",
    "        class_mode=\"raw\",\n",
    "        seed=SEED,\n",
    "        interpolation = 'bicubic',\n",
    "        shuffle=False,\n",
    "    )\n",
    "        prediction_all = model.predict(all_img)\n",
    "        prediction = pd.DataFrame(prediction_all, columns=feature_columns).join(pd.DataFrame(all_img._targets, columns=feature_columns), rsuffix='_true', lsuffix = '_pred')\n",
    "        prediction.index = all_img.filenames\n",
    "    elif predict_valid:       \n",
    "        prediction_valid = model.predict(valid)\n",
    "        prediction = pd.DataFrame(prediction_valid, columns=feature_columns).join(pd.DataFrame(valid._targets, columns=feature_columns), rsuffix='_true', lsuffix = '_pred')\n",
    "        prediction.index = valid.filenames\n",
    "    elif predict_train:\n",
    "        train = train_datagen.flow_from_dataframe(\n",
    "            dataframe=labels,\n",
    "            directory=IMG_PATH,\n",
    "            x_col=\"image\",\n",
    "            y_col=feature_columns,\n",
    "            target_size=IMAGE_SIZE,\n",
    "            batch_size=BATCH_SIZE,\n",
    "            class_mode=\"raw\",\n",
    "            subset=\"training\",\n",
    "            seed=SEED,\n",
    "            interpolation = 'bicubic',\n",
    "            shuffle=False\n",
    "        )\n",
    "        prediction_train = model.predict(train)\n",
    "        prediction = pd.DataFrame(prediction_train, columns=feature_columns).join(pd.DataFrame(train._targets, columns=feature_columns), rsuffix='_true', lsuffix = '_pred')\n",
    "        prediction.index = train.filenames\n",
    "    return prediction\n",
    "\n",
    "\n",
    "def get_metrics(prediction_df, show=True):\n",
    "    metrics_df = pd.DataFrame()\n",
    "    for col in feature_columns:\n",
    "        pres = metrics.precision_score(prediction_df[col+'_true'], prediction_df[col+'_pred']>0.5)\n",
    "        rec = metrics.recall_score(prediction_df[col+'_true'], prediction_df[col+'_pred']>0.5)\n",
    "        f1 = metrics.f1_score(prediction_df[col+'_true'], prediction_df[col+'_pred']>0.5)\n",
    "        metrics_df.loc['precision', col] = pres\n",
    "        metrics_df.loc['recall', col] = rec\n",
    "        metrics_df.loc['f1_score', col] = f1\n",
    "    if show:\n",
    "        print(metrics_df)\n",
    "    return metrics_df\n",
    "\n",
    "\n",
    "def wrong_prediction(prediction_df, treshold = 0.5):\n",
    "    list_wrong_prediction = []\n",
    "    prediction = prediction_df.copy()\n",
    "    for col in feature_columns:\n",
    "        prediction[col+'_pred'] = prediction[col+'_pred'] > treshold\n",
    "        prediction[col+'_pred'] = prediction[col+'_pred'].replace({True: 1, False: 0})\n",
    "        ids = prediction[prediction[col+'_true'] != prediction[col+'_pred']].index.tolist()\n",
    "        list_wrong_prediction.extend(ids)\n",
    "    list_wrong_prediction = set(list_wrong_prediction)\n",
    "    wrong_prediction = prediction.loc[list_wrong_prediction]\n",
    "    for img in wrong_prediction.index.tolist():\n",
    "        pred = wrong_prediction.loc[img][:6].values\n",
    "        real = wrong_prediction.loc[img][6:12].values\n",
    "        pred_names = ' '.join(list(map(lambda x,y: x*y, pred,feature_columns)))\n",
    "        pred_names = ' '.join(pred_names.split())\n",
    "        real_names = ' '.join(list(map(lambda x,y: x*y, real,feature_columns)))\n",
    "        real_names = ' '.join(real_names.split())\n",
    "        wrong_prediction.loc[img, 'pred_labels'] = pred_names\n",
    "        wrong_prediction.loc[img, 'real_labels'] = real_names\n",
    "    return prediction, wrong_prediction\n",
    "\n",
    "\n",
    "def plot_wrongs(df, num_im = 20):\n",
    "    plt.figure(figsize=(15,(num_im//4)*5))\n",
    "    for i, img in enumerate(df.sample(num_im).index.tolist()):\n",
    "        image = Image.open(IMG_PATH +img)\n",
    "        plt.subplot(num_im//4, 4, i+1)\n",
    "        plt.title('predicted: '+df.loc[img,'pred_labels']+ '\\nreal: '+df.loc[img,'real_labels'])\n",
    "        plt.imshow(image)\n",
    "        plt.xticks([])\n",
    "        plt.yticks([])\n",
    "    plt.tight_layout()\n",
    "    plt.show();"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
